<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<title>Retro Space Invaders X</title>
<style>
    body{margin:0;padding:0;background:#000;color:#0f0;font-family:'Courier New',monospace;display:flex;flex-direction:column;align-items:center;justify-content:center;height:100vh;overflow:hidden;touch-action:none;}
    #game-container{position:relative;box-shadow:0 0 30px rgba(0,255,0,0.4);border:3px solid #0f0;overflow:hidden;background-color:#000;transform-origin:top center;transition:transform .3s ease;}
    canvas{display:block;background:#000;}
    #ui-layer{position:absolute;top:0;left:0;width:100%;height:100%;pointer-events:none;}
    .hud-top{display:flex;justify-content:space-between;padding:15px;font-size:20px;text-transform:uppercase;letter-spacing:2px;background:linear-gradient(to bottom,rgba(0,0,0,0.9),transparent);}
    .overlay-message{position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);background:rgba(0,0,0,0.92);padding:25px 40px;border:2px solid #0f0;box-shadow:0 0 15px #0f0;text-align:center;pointer-events:none;text-transform:uppercase;letter-spacing:2px;}
    .overlay-message p{margin:8px 0;font-size:20px;}
    #start-screen,#game-over-screen{position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);background:rgba(0,0,0,0.95);padding:40px;border:2px solid #0f0;box-shadow:0 0 20px #0f0;text-align:center;pointer-events:auto;z-index:10;min-width: 300px;}
    .hidden{display:none!important;}
    h1{font-size:40px;margin:0 0 20px 0;text-shadow:0 0 15px #0f0;}
    p {margin: 10px 0; font-size: 16px;}
    button{background:#0f0;color:#000;border:none;padding:15px 35px;font-size:22px;font-weight:bold;cursor:pointer;margin:10px;text-transform:uppercase;transition:.2s;font-family:inherit;}
    button:hover{background:#fff;box-shadow:0 0 20px #fff;}
    .low-ammo{color:#f00!important;text-shadow:0 0 10px #f00!important;animation:pulse 1s infinite;}
    @keyframes pulse{0%,100%{opacity:1}50%{opacity:0.4}}
    .crt::after{content:"";position:absolute;top:0;left:0;width:100%;height:100%;background:linear-gradient(transparent 50%,rgba(0,255,0,0.05) 50%),linear-gradient(90deg,rgba(0,255,0,0.03) 1px,transparent 1px);background-size:100% 4px,4px 100%;pointer-events:none;mix-blend-mode:overlay;}
    
    /* Responsive adjustments */
    @media (max-width: 600px) {
        h1 { font-size: 30px; }
        .hud-top { font-size: 14px; padding: 10px; }
        #gameCanvas { width: 100%; height: 100%; }
        #game-container { width: 100%; height: 100%; border: none; }
    }
</style>
</head>
<body>

<div id="game-container" class="crt">
    <canvas id="gameCanvas" width="1200" height="700"></canvas>
    
    <div id="ui-layer">
        <div class="hud-top">
            <div>Score: <span id="score">0</span></div>
            <div>Wave: <span id="wave">1</span></div>
            <div>High: <span id="high-score">0</span></div>
            <div>Lives: <span id="lives">3</span></div>
            <div>Ammo: <span id="ammo">30</span></div>
        </div>
        <div id="pause-overlay" class="overlay-message hidden">
            <p>PAUSED</p>
            <p style="font-size:16px; color:#0f0; letter-spacing:1px;">Press ESC to resume</p>
        </div>
    </div>

    <div id="start-screen">
        <h1>SPACE INVADERS X</h1>
        <p>Defend Earth • Watch your ammo!</p>
        <p style="color:#ff00ff; font-size: 14px;">Shoot UFOs → +10 Ammo • Every 3rd = +1 Life</p>
        <p style="color:#0ff; font-size: 14px; letter-spacing: 1px;">
            Controls: A / ← move left • D / → move right • Space to fire • ESC pauses
        </p>
        <button onclick="startGame()">LAUNCH</button>
    </div>

    <div id="game-over-screen" class="hidden">
        <h1 style="color:#f00;">GAME OVER</h1>
        <p id="final-score">Score: 0</p>
        <button onclick="startGame()">TRY AGAIN</button>
    </div>

</div>

<!-- Placeholders for audio - standard beeps would be generated here in a full production -->
<audio id="sfx-shoot" src="data:audio/wav;base64,UklGRiQAAABXQVZFZm10IBAAAAABAAEAQB8AAEAfAAABAAgAZGF0YQAAAAA="></audio>
<audio id="sfx-hit" src="data:audio/wav;base64,UklGRl4AAABXQVZFZm10IBAAAAABAAEAIlYAAESsAAACABAAZGF0YQAAAAA="></audio>
<audio id="sfx-explosion" src="data:audio/wav;base64,UklGRnoBAABXQVZFZm10IBAAAAABAAEAQB8AAEAfAAABAAgAZGF0YQAAAAA="></audio>
<audio id="sfx-ufo" src="data:audio/wav;base64,UklGRkQCAABXQVZFZm10IBAAAAABAAEAQB8AAEAfAAABAAgAZGF0YQAAAAA="></audio>
<audio id="sfx-playerhit" src="data:audio/wav;base64,UklGRmQAAABXQVZFZm10IBAAAAABAAEAIlYAAESsAAACABAAZGF0YQAAAAA="></audio>

<script>
'use strict';

const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
const container = document.getElementById('game-container');
const scoreEl = document.getElementById('score');
const waveEl = document.getElementById('wave');
const highScoreEl = document.getElementById('high-score');
const ammoEl = document.getElementById('ammo');
const livesEl = document.getElementById('lives');
const startScreen = document.getElementById('start-screen');
const gameOverScreen = document.getElementById('game-over-screen');
const finalScoreEl = document.getElementById('final-score');
const pauseOverlay = document.getElementById('pause-overlay');

// Responsive scaling
const DESIGN_WIDTH=canvas.width;
const DESIGN_HEIGHT=canvas.height;
function fitGameToViewport(){
    const targetWidth=Math.max(500,window.innerWidth*0.66);
    const targetHeight=Math.max(350,window.innerHeight*0.88);
    const scaleW=targetWidth/DESIGN_WIDTH;
    const scaleH=targetHeight/DESIGN_HEIGHT;
    const scale=Math.max(0.5,Math.min(scaleW,scaleH,2.5));
    container.style.transform=`scale(${scale})`;
}
window.addEventListener('resize', fitGameToViewport);
fitGameToViewport();

// Sounds
const sounds = {
    shoot: document.getElementById('sfx-shoot'),
    hit: document.getElementById('sfx-hit'),
    explosion: document.getElementById('sfx-explosion'),
    ufo: document.getElementById('sfx-ufo'),
    playerhit: document.getElementById('sfx-playerhit')
};
function play(sound){ try{sound.currentTime=0; sound.play();}catch(e){} }

// Game state
const keys={a:{pressed:false},d:{pressed:false},space:{pressed:false}};
let player, projectiles=[], grids=[], ufos=[], invaderProjectiles=[], particles=[], stars=[], drops=[];
let score=0, wave=1, highScore=localStorage.getItem('invaders_hs')||0, ufosKilled=0;
let gameActive=false, gamePaused=false, lastTime=0;
let ufoSpawnTimer=0;
let difficulty;
let shakeX=0, shakeY=0, shakeTimer=0;
let boss=null;

// Particle Pool
const PARTICLE_POOL_SIZE=200;
const particlePool=[];

// Starfield
for(let i=0;i<150;i++){
    stars.push({x:Math.random()*canvas.width,y:Math.random()*canvas.height,s:Math.random()*2+0.5});
}

const INVADER_COLORS=['#ff4d6d','#ffb347','#6cfb72','#68d8ff','#c08bff','#ffec5c','#ff8fab','#55f0d5'];
const MAX_POWER_LEVEL=4;
const SHIELD_MAX_HITS=3;
function getWaveColor(index=wave){
    return INVADER_COLORS[(Math.max(0,index-1))%INVADER_COLORS.length];
}
function getPowerLevelForScore(points){
    return Math.min(MAX_POWER_LEVEL,1+Math.floor(points/10000));
}
const PROJECTILE_BASE_DAMAGE=18;
const PROJECTILE_DAMAGE_STEP=6;
const SHOT_PATTERNS={
    1:[{offset:0,xVel:0,yVel:-12}],
    2:[{offset:-8,xVel:-0.5,yVel:-12},{offset:8,xVel:0.5,yVel:-12}],
    3:[
        {offset:0,xVel:0,yVel:-12.5},
        {offset:-12,xVel:-0.8,yVel:-11.2},
        {offset:12,xVel:0.8,yVel:-11.2}
    ],
    4:[
        {offset:0,xVel:0,yVel:-12.8},
        {offset:-14,xVel:-1,yVel:-11.5},
        {offset:14,xVel:1,yVel:-11.5},
        {offset:-32,xVel:-1.2,yVel:-10.5},
        {offset:32,xVel:1.2,yVel:-10.5}
    ]
};
function getProjectileDamage(){
    const level=player?.powerLevel||1;
    return PROJECTILE_BASE_DAMAGE+(level-1)*PROJECTILE_DAMAGE_STEP;
}

function getDifficultySnapshot(){
    const progression=Math.max(0,wave-1);
    const capped=Math.min(progression,20);
    // Every 10 levels, get harder
    const loop=Math.floor((wave-1)/10);
    const loopFactor=loop*0.5; // Increase speed per loop
    
    return {
        gridSpeed:(1.5+capped*0.18)+loopFactor,
        fireChance:0.00045+capped*0.00012+(loop*0.0001),
        ufoInterval:Math.max(3000,12000-capped*450-(loop*500))
    };
}
function refreshDifficulty(){
    difficulty=getDifficultySnapshot();
}
refreshDifficulty();

// Classes
class Player{
    constructor(){
        this.width=56;
        this.height=38;
        this.position={x:canvas.width/2-28,y:canvas.height-80};
        this.speed=6;
        this.lives=3;
        this.ammo=30;
        this.powerLevel=1;
        this.shieldHP=0;
        this.shieldPulse=0;
    }
    draw(){
        const {x,y}=this.position;
        const fuselageWidth=22;
        const fuselageOffset=(this.width-fuselageWidth)/2;
        ctx.save();
        ctx.translate(x,y);
        ctx.shadowColor='#7af9ff';
        ctx.shadowBlur=3;

        // Cross wings
        ctx.fillStyle='#c6c9d0';
        ctx.fillRect(-14,6,26,5); // upper-left
        ctx.fillRect(-14,this.height-13,26,5); // lower-left
        ctx.fillRect(this.width-12,6,26,5); // upper-right
        ctx.fillRect(this.width-12,this.height-13,26,5); // lower-right

        // Wing cannons
        ctx.fillStyle='#7c7f86';
        ctx.fillRect(-18,5,4,7);
        ctx.fillRect(-18,this.height-12,4,7);
        ctx.fillRect(this.width+10,5,4,7);
        ctx.fillRect(this.width+10,this.height-12,4,7);

        // Engine pods
        const engineColor='#f04d3a';
        ctx.fillStyle=engineColor;
        [-8,this.width+4].forEach((px,idx)=>{
            ctx.beginPath();
            ctx.ellipse(px,11,4,6,0,0,Math.PI*2);
            ctx.fill();
            ctx.beginPath();
            ctx.ellipse(px,this.height-11,4,6,0,0,Math.PI*2);
            ctx.fill();
        });

        // Fuselage
        const hullGrad=ctx.createLinearGradient(0,0,0,this.height);
        hullGrad.addColorStop(0,'#f5f5f5');
        hullGrad.addColorStop(0.45,'#cfd2d8');
        hullGrad.addColorStop(1,'#7a818a');
        ctx.fillStyle=hullGrad;
        ctx.fillRect(fuselageOffset,4,fuselageWidth,this.height-8);

        // Nose cone
        ctx.beginPath();
        ctx.moveTo(this.width/2,0);
        ctx.lineTo(this.width/2+6,10);
        ctx.lineTo(this.width/2-6,10);
        ctx.closePath();
        ctx.fillStyle='#cfd2d8';
        ctx.fill();

        // Red squadron stripes
        ctx.fillStyle='#ff724f';
        ctx.fillRect(fuselageOffset+2,10,fuselageWidth-4,4);
        ctx.fillRect(fuselageOffset+2,this.height-16,fuselageWidth-4,3);

        // Cockpit bubble
        const domeGrad=ctx.createRadialGradient(this.width/2-2,8,2,this.width/2,20,14);
        domeGrad.addColorStop(0,'#c8f1ff');
        domeGrad.addColorStop(0.6,'#6fb8ff');
        domeGrad.addColorStop(1,'rgba(0,0,0,0.35)');
        ctx.fillStyle=domeGrad;
        ctx.beginPath();
        ctx.ellipse(this.width/2,12,9,13,0,0,Math.PI*2);
        ctx.fill();

        // Thruster glow
        const thrusterGrad=ctx.createRadialGradient(this.width/2,this.height-2,2,this.width/2,this.height+12,18);
        thrusterGrad.addColorStop(0,'rgba(255,255,255,0.9)');
        thrusterGrad.addColorStop(0.35,'rgba(255,190,90,0.8)');
        thrusterGrad.addColorStop(1,'rgba(255,120,0,0)');
        ctx.fillStyle=thrusterGrad;
        ctx.beginPath();
        ctx.ellipse(this.width/2,this.height-2,6,11,0,0,Math.PI*2);
        ctx.fill();

        ctx.restore();
        ctx.shadowBlur=0;

        // Forward-floating shield arc
        if(this.shieldHP>0){
            const strength=this.shieldHP/SHIELD_MAX_HITS;
            const offsetY=-12;
            const gradient=ctx.createLinearGradient(x,this.position.y+offsetY,x+this.width,this.position.y+offsetY-40);
            gradient.addColorStop(0,'rgba(80,200,255,0)');
            gradient.addColorStop(0.5,`rgba(120,220,255,${0.35+0.4*strength})`);
            gradient.addColorStop(1,'rgba(80,200,255,0)');
            ctx.strokeStyle=gradient;
            ctx.lineWidth=3+(this.shieldPulse>0?1:0);
            ctx.beginPath();
            ctx.arc(x+this.width/2,this.position.y-15,45,Math.PI*0.75,Math.PI*0.25,false);
            ctx.stroke();
            if(this.shieldPulse>0) this.shieldPulse--;
        }

        // Muzzle flash hint
        if(keys.space.pressed && player.ammo>0 && Math.random()<0.5){
            ctx.fillStyle='#fff6a1';
            ctx.fillRect(x+this.width/2-2,y-8,4,14);
        }
    }
    update(){
        if(keys.a.pressed && this.position.x>0) this.position.x-=this.speed;
        if(keys.d.pressed && this.position.x+this.width<canvas.width) this.position.x+=this.speed;
        this.draw();
    }
}

class Projectile{constructor({position,velocity,color='white',radius=4,isNuke=false}){this.position={...position};this.velocity=velocity;this.radius=radius;this.color=color;this.isNuke=isNuke;}
    draw(){
        ctx.save();
        ctx.shadowBlur=this.isNuke?20:15;
        ctx.shadowColor=this.color;
        ctx.fillStyle=this.color;
        ctx.beginPath();
        ctx.arc(this.position.x,this.position.y,this.radius,0,Math.PI*2);
        ctx.fill();
        ctx.shadowBlur=0;
        ctx.restore();
    }
    update(){this.position.x+=this.velocity.x;this.position.y+=this.velocity.y;this.draw();}
}

class Invader{
    constructor({position,color}){
        this.position={...position};
        this.width=32;
        this.height=26;
        this.color=color||'#ff4d6d';
        this.eyeColor='#020202';
        this.panelColor='#0c0c0c';
    }
    draw(frame){
        const bob = Math.sin(frame/120)*2;
        const armSwing = Math.sin(frame/80)*4;
        ctx.save();
        ctx.translate(bob,0);
        ctx.shadowColor=this.color;
        ctx.shadowBlur=3;
        // upper hull
        ctx.fillStyle=this.color;
        ctx.fillRect(this.position.x+4,this.position.y,this.width-8,10);
        // lower hull
        ctx.fillRect(this.position.x,this.position.y+10,this.width,12);
        // articulated arms
        ctx.fillRect(this.position.x-10,this.position.y+8+armSwing,6,16);
        ctx.fillRect(this.position.x+this.width+4,this.position.y+8-armSwing,6,16);
        // wing tips
        ctx.fillRect(this.position.x-4,this.position.y+12,8,6);
        ctx.fillRect(this.position.x+this.width-4,this.position.y+12,8,6);
        // cockpit glow
        ctx.fillStyle='#fff6d5';
        ctx.fillRect(this.position.x+this.width/2-4,this.position.y+3,8,6);
        // panels / vents
        ctx.fillStyle=this.panelColor;
        ctx.fillRect(this.position.x+6,this.position.y+14,4,6);
        ctx.fillRect(this.position.x+this.width-10,this.position.y+14,4,6);
        // eyes
        ctx.fillStyle=this.eyeColor;
        ctx.fillRect(this.position.x+10,this.position.y+6,4,4);
        ctx.fillRect(this.position.x+this.width-14,this.position.y+6,4,4);
        ctx.restore();
        ctx.shadowBlur=0;
    }
    update({velocity,frame}){this.position.x+=velocity.x;this.position.y+=velocity.y;this.draw(frame);}
    shoot(){
        invaderProjectiles.push(new Projectile({
            position:{x:this.position.x+this.width/2,y:this.position.y+this.height},
            velocity:{x:0,y:3.2},
            color:'#ff5c5c'
        }));
    }
}

class UFO{
    constructor(){
        const fromLeft=Math.random()>0.5;
        this.width = 80;
        this.height = 28;
        this.baseY=50+Math.random()*50;
        this.position={
            x:fromLeft?-this.width-40:canvas.width+this.width+40,
            y:this.baseY
        };
        this.velocity={x:fromLeft?3.4:-3.4,y:0};
        this.wobblePhase=Math.random()*Math.PI*2;
    }
    draw(frameTime=0){
        const wobble=Math.sin(frameTime/250+this.wobblePhase)*4;
        const centerX=this.position.x+this.width/2;
        const centerY=this.position.y+this.height/2;
        ctx.save();
        ctx.translate(0,wobble);
        ctx.shadowColor='#b300ff';
        ctx.shadowBlur=6;

        // glowing undercarriage
        const engineGrad=ctx.createLinearGradient(centerX,centerY+6,centerX,centerY+16);
        engineGrad.addColorStop(0,'rgba(255,120,255,0.85)');
        engineGrad.addColorStop(1,'rgba(255,120,255,0)');
        ctx.fillStyle=engineGrad;
        ctx.beginPath();
        ctx.ellipse(centerX,centerY+10,this.width/2.6,this.height/2.2,0,0,Math.PI*2);
        ctx.fill();

        // main hull with 3D shading
        const hullGrad=ctx.createLinearGradient(centerX,this.position.y,centerX,this.position.y+this.height);
        hullGrad.addColorStop(0,'#ffd2ff');
        hullGrad.addColorStop(0.4,'#c154ff');
        hullGrad.addColorStop(1,'#320040');
        ctx.fillStyle=hullGrad;
        ctx.beginPath();
        ctx.ellipse(centerX,centerY,this.width/2,this.height/2,0,0,Math.PI*2);
        ctx.fill();

        // metallic rim
        ctx.strokeStyle='rgba(255,255,255,0.18)';
        ctx.lineWidth=2;
        ctx.beginPath();
        ctx.ellipse(centerX,centerY,this.width/2-4,this.height/2-4,0,0,Math.PI*2);
        ctx.stroke();

        // top plate
        const plateGrad=ctx.createLinearGradient(centerX,this.position.y-6,centerX,this.position.y+10);
        plateGrad.addColorStop(0,'#ffe8ff');
        plateGrad.addColorStop(1,'#7b2cbf');
        ctx.fillStyle=plateGrad;
        ctx.beginPath();
        ctx.ellipse(centerX,this.position.y+3,this.width/3.2,this.height/2.3,0,0,Math.PI*2);
        ctx.fill();

        // glass dome
        const domeGrad=ctx.createRadialGradient(centerX-6,this.position.y-4,3,centerX,this.position.y+2,22);
        domeGrad.addColorStop(0,'#c8f7ff');
        domeGrad.addColorStop(0.5,'#6ed4ff');
        domeGrad.addColorStop(1,'rgba(0,0,0,0.1)');
        ctx.fillStyle=domeGrad;
        ctx.beginPath();
        ctx.ellipse(centerX,this.position.y-2,this.width/4.5,this.height/1.6,0,0,Math.PI*2);
        ctx.fill();

        // dome highlight
        ctx.fillStyle='rgba(255,255,255,0.6)';
        ctx.beginPath();
        ctx.ellipse(centerX-10,this.position.y-6,this.width/10,this.height/4,Math.PI/8,0,Math.PI*2);
        ctx.fill();

        // engine lights
        ctx.fillStyle='#fffb8c';
        for(let i=-2;i<=2;i++){
            ctx.beginPath();
            ctx.arc(centerX+i*10,this.position.y+this.height-4,3,0,Math.PI*2);
            ctx.fill();
        }

        ctx.restore();
        ctx.shadowBlur=0;
    }
    update(frameTime=performance.now()){
        this.position.x+=this.velocity.x;
        this.draw(frameTime);
    }
}

class Particle{constructor({position,velocity,radius,color,fades}){this.position={...position};this.velocity=velocity;this.radius=radius;this.color=color;this.opacity=1;this.fades=fades;this.dead=false;}
    draw(){ctx.save();ctx.globalAlpha=this.opacity;ctx.fillStyle=this.color;ctx.beginPath();ctx.arc(this.position.x,this.position.y,this.radius,0,Math.PI*2);ctx.fill();ctx.restore();}
    update(){
        this.position.x+=this.velocity.x;
        this.position.y+=this.velocity.y;
        if(this.fades)this.opacity-=0.02;
        if(this.opacity<=0) this.dead=true;
        this.draw();
    }
    reset({position,velocity,radius,color,fades}){
        this.position={...position};
        this.velocity=velocity;
        this.radius=radius;
        this.color=color;
        this.opacity=1;
        this.fades=fades;
        this.dead=false;
    }
}

function spawnParticle(config){
    const p=particlePool.find(p=>p.dead);
    if(p){
        p.reset(config);
        return p;
    }
    const newP=new Particle(config);
    particlePool.push(newP);
    return newP;
}

class Drop{
    constructor({position,type}){
        this.position={...position};
        this.velocity={x:0,y:2.5};
        this.type=type; // 'life', 'shield', 'ammo'
        this.width=20;
        this.height=20;
        this.angle=0;
    }
    draw(){
        ctx.save();
        ctx.translate(this.position.x+10,this.position.y+10);
        ctx.rotate(this.angle);
        this.angle+=0.05;
        ctx.shadowBlur=10;
        if(this.type==='life'){
            ctx.shadowColor='#f00';
            ctx.fillStyle='#f00';
            ctx.fillRect(-6,-6,12,4);
            ctx.fillRect(-2,-10,4,12);
        }else if(this.type==='shield'){
            ctx.shadowColor='#0ff';
            ctx.strokeStyle='#0ff';
            ctx.lineWidth=3;
            ctx.beginPath();
            ctx.arc(0,0,8,0,Math.PI*2);
            ctx.stroke();
        }else{
            ctx.shadowColor='#0f0';
            ctx.fillStyle='#0f0';
            ctx.fillRect(-5,-8,10,16);
        }
        ctx.restore();
    }
    update(){
        this.position.y+=this.velocity.y;
        this.draw();
    }
}

class Grid{
    constructor(speed=difficulty.gridSpeed,color=getWaveColor()){
        const approachSpeed=0.08+Math.min(0.12,(wave-1)*0.01);
        this.velocity={x:speed,y:approachSpeed};
        this.color=color;
        this.invaders=[];
    const maxCols = Math.floor((canvas.width - 40) / 40); 
    const cols = Math.min(10, Math.max(3, maxCols));
    const rows = Math.min(3+Math.floor(wave/3),6);

    const gridWidth = cols * 40; 
    const startX = (canvas.width - gridWidth) / 2;
    
        for(let x=0;x<cols;x++)for(let y=0;y<rows;y++){
            this.invaders.push(new Invader({
                position:{x:startX+x*40,y:80+y*45},
                color:this.color
            }));
        }
    }
    update(frame){this.position={x:0,y:0};this.invaders.forEach(i=>i.update({velocity:this.velocity,frame}));
        if(this.invaders.length>0){
            const rightMost = this.invaders.reduce((a,b)=>b.position.x>a.position.x?b:a);
            const leftMost = this.invaders.reduce((a,b)=>b.position.x<a.position.x?b:a);
            
            if((rightMost.position.x+30>=canvas.width && this.velocity.x>0)||(leftMost.position.x<=0 && this.velocity.x<0)){
                this.velocity.x = -this.velocity.x;
                this.invaders.forEach(inv => inv.position.y += 30);
            }
        }
    }
}

class Boss{
    constructor(){
        this.width=180;
        this.height=70;
        this.position={x:canvas.width/2-90,y:60};
        this.velocity={x:2.4+Math.floor(wave/10)*0.5,y:0}; // Faster per 10 waves
        this.health=1600+Math.floor(wave/10)*1000; // More health per 10 waves
        this.maxHealth=this.health;
        this.fireTimer=700;
        this.dying=false;
        this.deathTimer=0;
    }
    draw(){
        ctx.save();
        ctx.shadowColor='#ff00ff';
        ctx.shadowBlur=25;
        if(this.dying){
            ctx.globalAlpha=0.5+Math.sin(performance.now()/50)*0.5;
            ctx.translate((Math.random()-0.5)*10,(Math.random()-0.5)*10);
        }
        // Main hull
        ctx.fillStyle='#5e00ff';
        ctx.fillRect(this.position.x,this.position.y+15,this.width,35);
        // Upper fins
        ctx.fillStyle='#b900ff';
        ctx.fillRect(this.position.x+20,this.position.y,this.width-40,20);
        // side spikes
        ctx.fillRect(this.position.x-10,this.position.y+20,20,20);
        ctx.fillRect(this.position.x+this.width-10,this.position.y+20,20,20);
        // engine glow
        const grad=ctx.createLinearGradient(this.position.x,this.position.y+50,this.position.x,this.position.y+70);
        grad.addColorStop(0,'#ff6a00');
        grad.addColorStop(1,'rgba(255,106,0,0)');
        ctx.fillStyle=grad;
        ctx.fillRect(this.position.x+10,this.position.y+50,this.width-20,15);
        // cockpit
        ctx.fillStyle='#fff';
        ctx.fillRect(this.position.x+this.width/2-15,this.position.y+5,30,18);
        ctx.restore();

        // Health bar
        if(!this.dying){
            ctx.fillStyle='rgba(255,255,255,0.2)';
            ctx.fillRect(canvas.width/2-140,25,280,10);
            ctx.fillStyle='#ff00ff';
            ctx.fillRect(canvas.width/2-140,25,(this.health/this.maxHealth)*280,10);
        }
    }
    update(delta){
        if(this.dying){
            this.deathTimer-=delta;
            if(Math.random()<0.3){
                createExplosion({
                    position:{
                        x:this.position.x+Math.random()*this.width,
                        y:this.position.y+Math.random()*this.height
                    },
                    width:10,height:10
                },'#ff00ff',10);
            }
            this.draw();
            return;
        }
        this.position.x+=this.velocity.x;
        if(this.position.x<=20 || this.position.x+this.width>=canvas.width-20){
            this.velocity.x=-this.velocity.x;
            this.position.y=Math.min(this.position.y+12,canvas.height/2-100);
        }
        this.fireTimer-=delta;
        if(this.fireTimer<=0){
            this.fireTimer=650+Math.random()*250;
            this.shoot();
        }
        this.draw();
    }
    explode(){
        this.dying=true;
        this.deathTimer=2500; // 2.5 seconds of explosions
        shakeScreen(20,2500);
        createFloatingText("BOSS DESTROYED!",canvas.width/2,canvas.height/2,'#ff00ff');
    }
    shoot(){
        const cx=this.position.x+this.width/2;
        const muzzleY=this.position.y+this.height;
        [-1.5,0,1.5].forEach((angle,idx)=>{
            invaderProjectiles.push(new Projectile({
                position:{x:cx+(idx-1)*22,y:muzzleY},
                velocity:{x:angle*1.2,y:4.2},
                color:'#ff8c42',
                radius:6
            }));
        });
    }
    takeHit(dmg){
        this.health=Math.max(0,this.health-dmg);
    }
}

// Game functions
function createExplosion(obj,color,count=20){
    for(let i=0;i<count;i++){
        const p=spawnParticle({
            position:{x:obj.position.x+obj.width/2,y:obj.position.y+obj.height/2},
            velocity:{x:(Math.random()-0.5)*8,y:(Math.random()-0.5)*8},
            radius:Math.random()*4+1,color,fades:true
        });
        if(!particlePool.includes(p)) particles.push(p);
    }
    shakeScreen(7,300);
    play(sounds.explosion);
}

function shakeScreen(intensity,duration){
    shakeTimer=duration;
    shakeX=shakeY=intensity;
}

function createFloatingText(text,x,y,color='#fff'){
    const el=document.createElement('div');
    el.innerText=text;el.style.position='absolute';el.style.left=(x-50)+'px';el.style.top=(y-30)+'px';
    el.style.color=color;el.style.fontSize='28px';el.style.fontWeight='bold';el.style.pointerEvents='none';
    el.style.transition='all 1.2s ease-out';el.style.textShadow='0 0 5px #000';
    document.getElementById('game-container').appendChild(el);
    setTimeout(()=>{el.style.top=(y-100)+'px';el.style.opacity=0;},50);
    setTimeout(()=>el.remove(),1300);
}

function spawnBulletClash(x,y){
    for(let i=0;i<8;i++){
        const p=spawnParticle({
            position:{x,y},
            velocity:{x:(Math.random()-0.5)*4,y:(Math.random()-0.5)*4},
            radius:Math.random()*2+1,
            color:'#5ef8ff',
            fades:true
        });
        if(!particlePool.includes(p)) particles.push(p);
    }
}

function circlesIntersect(a,b){
    const dx=a.position.x-b.position.x;
    const dy=a.position.y-b.position.y;
    const combined=a.radius+b.radius;
    return dx*dx+dy*dy <= combined*combined;
}

function rectsIntersect(a,b){
    return a.position.x < b.position.x + b.width &&
        a.position.x + a.width > b.position.x &&
        a.position.y < b.position.y + b.height &&
        a.position.y + a.height > b.position.y;
}

function projectileHitsRect(projectile,rect){
    return projectile.position.x + projectile.radius > rect.position.x &&
        projectile.position.x - projectile.radius < rect.position.x + rect.width &&
        projectile.position.y + projectile.radius > rect.position.y &&
        projectile.position.y - projectile.radius < rect.position.y + rect.height;
}

function maybeUpgradeWeapons(){
    if(!player) return;
    const targetLevel=getPowerLevelForScore(score);
    if(targetLevel>player.powerLevel){
        player.powerLevel=targetLevel;
        createFloatingText(`Weapon Lv.${player.powerLevel}`,player.position.x+player.width/2,player.position.y-40,'#0ff');
        grantShield();
    }
}

function handleProjectileInterceptions(){
    for(let i=projectiles.length-1;i>=0;i--){
        let destroyed=false;
        for(let j=invaderProjectiles.length-1;j>=0;j--){
            if(circlesIntersect(projectiles[i],invaderProjectiles[j])){
                spawnBulletClash(projectiles[i].position.x,projectiles[i].position.y);
                projectiles.splice(i,1);
                invaderProjectiles.splice(j,1);
                if(player){
                    player.ammo+=10;
                    createFloatingText("+10 AMMO",player.position.x+player.width/2,player.position.y-30,'#0ff');
                    updateUI();
                }
                destroyed=true;
                break;
            }
        }
        if(destroyed) continue;
    }
}

function grantShield(silent=false){
    if(!player) return;
    player.shieldHP=SHIELD_MAX_HITS;
    player.shieldPulse=18;
    if(!silent){
        createFloatingText("Shield Recharged",player.position.x+player.width/2,player.position.y-55,'#6ffbff');
    }
}

function spawnShieldBurst(){
    if(!player) return;
    const cx=player.position.x+player.width/2;
    const cy=player.position.y+4;
    for(let i=0;i<14;i++){
        const p=spawnParticle({
            position:{x:cx,y:cy},
            velocity:{x:(Math.random()-0.5)*4,y:-Math.random()*3},
            radius:Math.random()*2+0.5,
            color:'#7fe0ff',
            fades:true
        });
        if(!particlePool.includes(p)) particles.push(p);
    }
}

function absorbShieldHit(){
    if(player && player.shieldHP>0){
        player.shieldHP--;
        player.shieldPulse=18;
        spawnShieldBurst();
        if(player.shieldHP===0){
            createFloatingText("Shield Down",player.position.x+player.width/2,player.position.y-45,'#6ffbff');
        }
        return true;
    }
    return false;
}

function shoot(){
    if(!gameActive||gamePaused||player.ammo<=0) return;
    const level=player.powerLevel||1;
    const pattern=SHOT_PATTERNS[level]||SHOT_PATTERNS[MAX_POWER_LEVEL];
    player.ammo--; updateUI(); play(sounds.shoot);
    const originX=player.position.x+player.width/2;
    const originY=player.position.y;
    pattern.forEach(shot=>{
        projectiles.push(new Projectile({
            position:{x:originX+shot.offset,y:originY},
            velocity:{x:shot.xVel,y:shot.yVel},
            color:level>=3?'#7fffd4':'#ffffff'
        }));
    });
}

function init(){
    player=new Player();
    projectiles=[]; grids=[]; ufos=[]; invaderProjectiles=[]; particles=[];
    score=0; wave=1; ufosKilled=0;
    ufoSpawnTimer=0; gameActive=true; gamePaused=false; lastTime=0;
    boss=null;
    Object.values(keys).forEach(key=>key.pressed=false);
    refreshDifficulty();
    grids=[new Grid(difficulty.gridSpeed,getWaveColor(1))];
    pauseOverlay.classList.add('hidden');
    updateUI();
}

function updateUI(){
    scoreEl.innerText=score;
    waveEl.innerText=boss?'BOSS':wave;
    highScoreEl.innerText=highScore;
    if(player) {
        ammoEl.innerText=player.ammo; livesEl.innerText=player.lives;
        ammoEl.classList.toggle('low-ammo',player.ammo<=5);
        maybeUpgradeWeapons();
    }
}

function endGame(reason=''){
    gameActive=false; gamePaused=false;
    pauseOverlay.classList.add('hidden');
    if(score>highScore){highScore=score;localStorage.setItem('invaders_hs',highScore);}
    const bossContext=boss || (reason && reason.toLowerCase().includes('boss'));
    const waveLabel=bossContext?'BOSS':wave;
    finalScoreEl.innerText=`Final Score: ${score} • Wave ${waveLabel}${reason?` • ${reason}`:''}`;
    gameOverScreen.classList.remove('hidden');
}

function startGame(){
    init(); startScreen.classList.add('hidden'); gameOverScreen.classList.add('hidden');
    requestAnimationFrame(animate);
}

function spawnBoss(){
    const isMega=(wave%100===0);
    boss=new Boss(isMega);
    createFloatingText(isMega?"MEGA BOSS!!":"FINAL BOSS!",canvas.width/2,canvas.height/2-80,isMega?'#ff0000':'#ff00ff');
}

function defeatBoss(){
    if(!boss || boss.dying) return;
    boss.explode();
    score+=7500;
    invaderProjectiles=[]; // Clear bullets so player doesn't die during victory
    updateUI();
}

function togglePause(){
    if(!gameActive) return;
    gamePaused=!gamePaused;
    pauseOverlay.classList.toggle('hidden',!gamePaused);
    if(!gamePaused){
        lastTime=0;
    }
}

function createDrop(x,y){
    const rand=Math.random();
    let type=null;
    if(rand<0.005) type='life';       // 0.5%
    else if(rand<0.02) type='shield'; // 1.5%
    else if(rand<0.06) type='ammo';   // 4%
    
    if(type){
        drops.push(new Drop({position:{x,y},type}));
    }
}

// Main loop
function animate(time){
    if(!gameActive) return;
    if(gamePaused){
        requestAnimationFrame(animate);
        return;
    }
    if(!lastTime) lastTime=time;
    const delta=time-lastTime; lastTime=time;
    ufoSpawnTimer+=delta;

    // Redraw background with shake support
    ctx.save();
    ctx.fillStyle='rgba(0,0,0,0.2)'; // Trails
    ctx.fillRect(0,0,canvas.width,canvas.height);

    // Shake
    if(shakeTimer>0){
        ctx.translate((Math.random()-0.5)*shakeX,(Math.random()-0.5)*shakeY);
        shakeTimer-=delta; shakeX*=0.95; shakeY*=0.95;
    }

    // Stars
    ctx.fillStyle='#fff';
    stars.forEach(s=>{s.y+=s.s; if(s.y>canvas.height) s.y=0; ctx.fillRect(s.x,s.y,1,1);});

    player.update();

    if(boss){
        boss.update(delta);
        if(boss.dying){
            if(boss.deathTimer<=0){
                boss=null;
                wave++;
                refreshDifficulty();
                grids.push(new Grid(difficulty.gridSpeed,getWaveColor(wave)));
                ufoSpawnTimer=0;
                updateUI();
            }
        }else if(rectsIntersect(boss,player)){
            if(absorbShieldHit()){
                play(sounds.hit);
                player.position.x=canvas.width/2-player.width/2;
            }else{
                player.lives=0;
                play(sounds.playerhit);
                createExplosion(player,'#0f0',60);
                updateUI();
                endGame('Boss Impact');
                return;
            }
        }
    }

    // Drops
    for(let i=drops.length-1;i>=0;i--){
        const d=drops[i];
        d.update();
        if(d.position.y>canvas.height){
            drops.splice(i,1);
            continue;
        }
        if(rectsIntersect(player,d)){
            if(d.type==='life'){
                player.lives++;
                createFloatingText("+1 LIFE",player.position.x,player.position.y-20,'#f00');
            }else if(d.type==='shield'){
                grantShield();
            }else{
                player.ammo+=30;
                createFloatingText("+30 AMMO",player.position.x,player.position.y-20,'#0f0');
            }
            drops.splice(i,1);
            updateUI();
        }
    }

    // UFO spawn
    if(!boss && ufoSpawnTimer>difficulty.ufoInterval && ufos.length===0){
        ufos.push(new UFO()); ufoSpawnTimer=0; play(sounds.ufo);
    }

    // Update everything with reverse loops
    for(let i=particles.length-1;i>=0;i--){
        particles[i].update();
        if(particles[i].dead){
            particles.splice(i,1);
        }
    }
    for(let i=ufos.length-1;i>=0;i--){
        const u=ufos[i]; u.update();
        const offLeft=-u.width-80;
        const offRight=canvas.width+u.width+80;
        if(u.position.x<offLeft||u.position.x>offRight){ufos.splice(i,1);continue;}
        for(let j=projectiles.length-1;j>=0;j--){
            const p=projectiles[j];
            if(p.position.y-p.radius<u.position.y+u.height&&p.position.x+p.radius>u.position.x&&p.position.x-p.radius<u.position.x+u.width&&p.position.y+p.radius>u.position.y){
                createExplosion(u,'#ff00ff',30); score+=500; player.ammo+=10; ufosKilled++;
                createFloatingText(ufosKilled%3===0?"+1 LIFE!":"+10 AMMO",u.position.x+30,u.position.y,'#ff00ff');
                if(ufosKilled%3===0){player.lives++; createFloatingText("+1 LIFE!",canvas.width/2,100,'#0f0');}
                ufos.splice(i,1); projectiles.splice(j,1); updateUI(); break;
            }
        }
    }

    // Grid logic
    for(let g=grids.length-1;g>=0;g--){
        const grid=grids[g]; grid.update(time);
        const fireChanceThisFrame=difficulty.fireChance*delta;
        if(grid.invaders.length>0 && Math.random()<fireChanceThisFrame){
            grid.invaders[Math.floor(Math.random()*grid.invaders.length)].shoot();
            play(sounds.hit);
        }
        for(let i=grid.invaders.length-1;i>=0;i--){
            const inv=grid.invaders[i];
            // Player bullet hits invader
            for(let j=projectiles.length-1;j>=0;j--){
                const p=projectiles[j];
                if(p.position.y-p.radius<inv.position.y+inv.height&&p.position.x+p.radius>inv.position.x&&p.position.x-p.radius<inv.position.x+inv.width&&p.position.y+p.radius>inv.position.y){
                    createExplosion(inv,inv.color||'#f00'); score+=100; player.ammo+=2;
                    createDrop(inv.position.x,inv.position.y);
                    grid.invaders.splice(i,1); projectiles.splice(j,1); updateUI(); break;
                }
            }
            // Invader reaches player
            if(inv.position.y+inv.height>=player.position.y){
                if(absorbShieldHit()){
                    play(sounds.hit);
                    grid.invaders.splice(i,1);
                    continue;
                }
                player.lives--; play(sounds.playerhit); createExplosion(player,'#0f0',40);
                if(player.lives<=0) endGame();
                else player.position.x=canvas.width/2-player.width/2;
                updateUI();
            }
        }
        if(grid.invaders.length===0){
            grids.splice(g,1);
            createFloatingText("WAVE COMPLETE!",canvas.width/2,canvas.height/2-50,'#0ff');
            wave++;
            refreshDifficulty();
            updateUI();
            if((wave%11===0 || wave%100===0) && !boss){
                spawnBoss();
            }else if(grids.length===0 && !boss){
                grids.push(new Grid(difficulty.gridSpeed,getWaveColor(wave)));
                ufoSpawnTimer=0;
            }
        }
    }

    handleProjectileInterceptions();

    // Player bullets
    for(let i=projectiles.length-1;i>=0;i--){
        const shot=projectiles[i];
        if(shot.position.y<=0){
            projectiles.splice(i,1);
            continue;
        }
        shot.update();
        if(boss && projectileHitsRect(shot,boss)){
            spawnBulletClash(shot.position.x,shot.position.y);
            boss.takeHit(getProjectileDamage());
            projectiles.splice(i,1);
            if(boss.health<=0){
                defeatBoss();
                break;
            }
        }
    }

    // Enemy bullets
    for(let i=invaderProjectiles.length-1;i>=0;i--){
        const p=invaderProjectiles[i];
        if(p.position.y>canvas.height){invaderProjectiles.splice(i,1);continue;}
        p.update();
        if(p.position.y+p.radius>player.position.y&&p.position.x>player.position.x&&p.position.x<player.position.x+player.width){
            invaderProjectiles.splice(i,1);
            if(absorbShieldHit()){
                play(sounds.hit);
                continue;
            }
            player.lives--; play(sounds.playerhit); createExplosion(player,'#0f0',40);
            if(player.lives<=0) endGame();
            else player.position.x=canvas.width/2-player.width/2;
            updateUI();
        }
    }

    ctx.restore();
    
    requestAnimationFrame(animate);
}

// Controls
window.addEventListener('keydown',e=>{
    if(e.key==='Escape'){
        if(gameActive){
            e.preventDefault();
            togglePause();
        }
        return;
    }
    if(!gameActive || gamePaused) return;
    if(e.key==='a'||e.key==='A' || e.key==='ArrowLeft'){ e.preventDefault(); keys.a.pressed=true; }
    if(e.key==='d'||e.key==='D' || e.key==='ArrowRight'){ e.preventDefault(); keys.d.pressed=true; }
    if(e.key===' '){
        e.preventDefault();
        keys.space.pressed=true;
        shoot();
    }
});
window.addEventListener('keyup',e=>{
    if(e.key==='a'||e.key==='A' || e.key==='ArrowLeft') keys.a.pressed=false;
    if(e.key==='d'||e.key==='D' || e.key==='ArrowRight') keys.d.pressed=false;
    if(e.key===' ') keys.space.pressed=false;
});


updateUI();
</script>
</body>
</html>